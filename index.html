<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quadrilateral Area Calculator</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    canvas {
      border: 1px solid #ccc;
    }
    .error {
      color: red;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div class="container mt-5">
    <h1 class="mb-4">Quadrilateral Area Calculator</h1>
    <p>Enter the side lengths of a quadrilateral (assumed trapezoid with front and back parallel).</p>
    
    <!-- Input Form -->
    <form id="quadForm">
      <div class="row">
        <div class="col-md-3 mb-3">
          <label for="left" class="form-label">Left Side (m)</label>
          <input type="number" class="form-control" id="left" min="0" step="0.01" required>
        </div>
        <div class="col-md-3 mb-3">
          <label for="front" class="form-label">Front Side (m)</label>
          <input type="number" class="form-control" id="front" min="0" step="0.01" required>
        </div>
        <div class="col-md-3 mb-3">
          <label for="right" class="form-label">Right Side (m)</label>
          <input type="number" class="form-control" id="right" min="0" step="0.01" required>
        </div>
        <div class="col-md-3 mb-3">
          <label for="back" class="form-label">Back Side (m)</label>
          <input type="number" class="form-control" id="back" min="0" step="0.01" required>
        </div>
      </div>
      <button type="button" class="btn btn-secondary mt-2" id="resetBtn">Reset</button>
    </form>

    <!-- Results Display -->
    <div id="results" class="mt-4">
      <h3>Area: <span id="areaValue">0</span> square meters</h3>
      <h3>Height: <span id="heightValue">0</span> meters</h3>
      <div id="errorMsg" class="error"></div>
    </div>

    <!-- Canvas for Visualization -->
    <canvas id="quadCanvas" width="400" height="300" class="mt-3"></canvas>
  </div>

  <script>
    // Get DOM elements
    const leftInput = document.getElementById('left');
    const frontInput = document.getElementById('front');
    const rightInput = document.getElementById('right');
    const backInput = document.getElementById('back');
    const areaValue = document.getElementById('areaValue');
    const heightValue = document.getElementById('heightValue');
    const errorMsg = document.getElementById('errorMsg');
    const canvas = document.getElementById('quadCanvas');
    const ctx = canvas.getContext('2d');
    const resetBtn = document.getElementById('resetBtn');

    // Add event listeners
    [leftInput, frontInput, rightInput, backInput].forEach(input => {
      input.addEventListener('input', update);
    });
    resetBtn.addEventListener('click', reset);

    // Update function to calculate area and draw shape
    function update() {
      // Parse input values
      const left = parseFloat(leftInput.value) || 0;
      const front = parseFloat(frontInput.value) || 0;
      const right = parseFloat(rightInput.value) || 0;
      const back = parseFloat(backInput.value) || 0;

      // Clear previous error
      errorMsg.textContent = '';

      // Check for non-positive inputs
      if (left <= 0 || front <= 0 || right <= 0 || back <= 0) {
        if (left < 0 || front < 0 || right < 0 || back < 0) {
          errorMsg.textContent = 'Side lengths must be positive.';
        }
        areaValue.textContent = '0';
        heightValue.textContent = '0';
        drawQuadrilateral(0, 0, 0, 0);
        return;
      }

      // Calculate x1 (horizontal offset of back relative to front)
      const diff = back - front;
      let x1, h;

      if (Math.abs(diff) < 1e-6) { // Parallelogram case (front ≈ back)
        if (Math.abs(right - left) < 1e-6) { // left ≈ right
          x1 = 0; // back aligns with front
          h = left; // height is simply the side length
        } else {
          errorMsg.textContent = 'Invalid quadrilateral: sides do not form a parallelogram.';
          areaValue.textContent = 'Invalid';
          heightValue.textContent = 'Invalid';
          drawQuadrilateral(0, 0, 0, 0);
          return;
        }
      } else {
        const numerator = right ** 2 - left ** 2 - diff ** 2;
        const denominator = 2 * diff;
        x1 = numerator / denominator;
        const h_squared = left ** 2 - x1 ** 2;
        
        if (h_squared <= 0) {
          errorMsg.textContent = 'Invalid quadrilateral: sides cannot form a valid shape.';
          areaValue.textContent = 'Invalid';
          heightValue.textContent = 'Invalid';
          drawQuadrilateral(0, 0, 0, 0);
          return;
        }
        h = Math.sqrt(h_squared);
      }

      // Calculate area
      const area = (front + back) * h / 2;
      areaValue.textContent = area.toFixed(2);
      heightValue.textContent = h.toFixed(2);

      // Draw the quadrilateral
      drawQuadrilateral(front, back, h, x1);
    }

    // Function to draw the quadrilateral on the canvas
    function drawQuadrilateral(front, back, h, x1) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (front <= 0 || back <= 0 || h <= 0) return;

      // Define the four vertices
      const points = [
        { x: 0, y: 0 },           // Bottom-left (D)
        { x: front, y: 0 },       // Bottom-right (C)
        { x: x1 + back, y: h },   // Top-right (B)
        { x: x1, y: h }           // Top-left (A)
      ];

      // Find bounds for scaling
      const maxX = Math.max(...points.map(p => p.x));
      const maxY = Math.max(...points.map(p => p.y));
      const minX = Math.min(...points.map(p => p.x));
      const minY = Math.min(...points.map(p => p.y));

      // Calculate scaling factors with padding
      const padding = 20;
      const scaleX = (canvas.width - 2 * padding) / (maxX - minX || 1);
      const scaleY = (canvas.height - 2 * padding) / (maxY - minY || 1);
      const scale = Math.min(scaleX, scaleY);

      // Center the shape
      const offsetX = (canvas.width - (maxX - minX) * scale) / 2 - minX * scale;
      const offsetY = (canvas.height - (maxY - minY) * scale) / 2 - minY * scale;

      // Draw the shape
      ctx.beginPath();
      points.forEach((p, i) => {
        const canvasX = p.x * scale + offsetX;
        const canvasY = canvas.height - (p.y * scale + offsetY); // Flip y-axis
        if (i === 0) {
          ctx.moveTo(canvasX, canvasY);
        } else {
          ctx.lineTo(canvasX, canvasY);
        }
      });
      ctx.closePath();
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Fill with a light color for better visibility
      ctx.fillStyle = 'rgba(0, 0, 255, 0.1)';
      ctx.fill();
    }

    // Reset function
    function reset() {
      [leftInput, frontInput, rightInput, backInput].forEach(input => {
        input.value = '';
      });
      areaValue.textContent = '0';
      heightValue.textContent = '0';
      errorMsg.textContent = '';
      drawQuadrilateral(0, 0, 0, 0);
    }
  </script>
</body>
</html>
